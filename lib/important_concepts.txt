Flutter Basics:
- Flutter is a multi-platform toolkit, can run on iOS, Android, Windows, macOS, Linux, web
- "Development Target" = OS your apps run on during development
- Flutter's most useful development feature is "Stateful Hot Reload"
- Flutter 3.35.6 // Dart 3.9.2 // Java 19.0.2
- command palette = f1
- select device = bottom right of screen "No Device"
- run with debugging = top right arrow
- hot reload by saving file - will update app without having to restart program
- Flutter makes use of trailing commas - good idea to use as they make adding more members trivial - also hep Dart's auto-formatter to work
- having separate widgets for separate logical parts of your UI is an important way of managing complexity in Flutter
- Refactor menu = 'Ctrl + .' whilst selecting the piece of code you want to refactor - can extract / wrap
- Dart is null-safe so won't let you call methods of objects that are potentially null - '!' (bang operator) assures Dart you kno what you're doing
- to access ful list of changeable properties - place cusor within () and hit Ctrl + Shift + Space
- use Widget Inspector whilst debugging to see where widgets extend to (e.g. a column) - can then use the Refactor menu to add a Centre
- MyAppState previously covered all state needs - all the widgets were stateless - they don't contain a mutable state of their own - none of the widgets could change iteslf - must go through MyAppState
- can keep adding properties to MyAppState - but the class would grow beyond reason
- some state is only relevant to a single widget - so it should stay with that widget - hence you can use a StatefulWidget - a widget with a state
- can use the Refactor menu to convert a StatelessWidget > StatefulWidget
- Flutter works with logical pixels as a unit of length (device independent pixels)

Dart Notes:
- Everything you can place in a varialbe is an object, and every object is an instance of a class
- Dart is strongly typed, type annotations are optional because Dart can infer types (e.g. using var)
- If you enable null safety, variables can't contain null unless specified
- When you want to explicitly say that any type is allowed - use the type Object? or Object
- Dart supports generic types, like List<int> or List<Object>
- Dart supports top-level functions (such as main()), as well as functions tied to a class or object (static and instance methods respectively). Can also create functions within functions (nested / local)
- Dart support top-level variables, as well as variables tied to a class or object (static and instance varaibles) - instance variable sometimes known as fields / properties
- Dart doesn't have keywords 'public', 'protected', and 'private' - use the underscore (_) before an indentifier to make it private
- Indentifiers can start with a letter or underscore
- Dart has both expressions (which have runtime values) and statements (which don't)
- Dart tools can report 2 kinds of problems: warnings and errors
- Warnings are indictors that your code might not work, but don't prevent your programs from executing
- Errors can be either compile-time or run-time. A compile-time error prevents the code from executing atall. A run-time error results in an exception being raised while the code executes

Dart Guide:
- Effective Dart: https://dart.dev/effective-dart (style guide, documentation guide, usage guide, design guide) 

Flutter Command Line:
- flutter pub get - fetches the packages your project depends on
- reads the pubspec.yaml file
- downloads the necessary packcages from pub.dev
- saves the exact versions in pubspec.lock so your project is reproducible
- puts the packcages in your local cache for Flutter and Dart to use

- flutter pub upgrade - tries to upgrade your dependcies to the latest versions allowed by your version contraints in pubspec.yaml
- fetches newer compatible versions than what's currently in pubspec.lock
- updated pubspec.lock to reflect these newer versions

Git Command line:
- git status
- git add <file_name> or '.' for all
- git commit -m "message"
- git push

Flutter Widgets:
- Build UIs using widgets and composing them together in a declarative manner
- Flutter offers an extensive set of widgets the closely match the Material Design (https://docs.flutter.dev/ui/widgets/material) specification
- Flutter controls every pixel on the screen, can create your own widgets

Build Context:
- A Widget doesn't know where it is in regard to other widgets in the Widget tree
- Element = information needed at runtime for this widget in this part of the app - all in an Element tree - all in reference to the Widget that they represent
- An Element is a type of context 
- Allows widget to figure out where it is, gives the widget build method the context it needs

Widgets vs Helper Methods:
- UI is made from wrapping Widgets in other Widgets
- Eventually, this build method becomes very large and needs breaking up
- First step is to make a judgement call - picking which codeblocks are good candidates for re use
- E.g. repeated sequences of code and discrete sections of actual UI, in other words things that are contained and / or repeat
- How to move the code? 
- 1) Is to move the code into a method in the same widget (helper method option) 
- 2) Similar, but instead of moving codeblock to method in same widet, move it into an entirely new widget
- Helper Methods have downsides 
- 1) Performance: when SetState() is called from within a widget, it's entire build method is re run, which is inefficient to rebuild whole sections of UI - so instead of using helper method - use an entire new widget so Flutter can target rebuilds, using const constructors is even more efficient
- 2) Testability: writing test on a separate widget is simple, however with helper methods, you're required to construct alot of irrelevant widgets
- 3) Accuracy: with helper methods, it's possible that stale build contexts are used - but with widgets, you can prevent this
- Overall, deafult to classes over methods - there's no functional benefit to methods other than ease of writing code 

Layouts in Flutter:
- Everything is a Widget, including layout models (e.g. rows, columns, grids that arrange, constaiin and align visible wigets - create a layout by composing widgets to build more complex widgets)
- Container is a widget that allows you to customise its child widget - use a Container when you want to, for example add padding, margins, borders, or background colour 
- Contnrol the rest of the UI with Widget's properties e.g. Icon's colour with 'color', Text's properties with 'Text.style', Column's properties for alignment and space
- Set 'debugPaintSizeEnabled' to true to see the visual layout of widgets (borders)

Lay Out a Widget:
- 1) Select a layout widget - based on how you want to align or constrain a visible widget e.g. Center()
- 2) Create a visible widget - e.g. Text()
- 3) Add visible widget to the layout widget - all layout widgets have either of the following: 1) a child property if they take a single child e.g. Center, Container 2) a children property is they take a list of widgets e.g. Row, Column, ListView, Stack
- 4) Add the layouut widget to the page - instantiating and returning a widget in the app's build() method displays the widget
- for a genneral app, you can add the Container widget to the app's build() method
- for a Material app, you can use a Scaffoold widget - it proviides a default banner, background colour, and has API for adding drawers, snack bars, and bottom sheets - can add the Center() widget diretly to the body property for the home page

Choosing Widgets
- Can use Flutter Widget of the week (https://www.youtube.com/watch?v=b_sQ9bMltGU&list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG)

Most Useful Layout Widgets: 
- (https://www.youtube.com/watch?v=RJEnTRBxaSg) 
- (https://www.youtube.com/watch?v=-zJ6CnOVndE)
- Row
- Column
- Stack
- Expanded
- Padding
- PageView
- ListView
- GridView
- Slivers
- CustomScrollView

More Complex Sliver Layouts: 
- (https://www.youtube.com/watch?v=E3-WdYBrEDc) 
- (https://www.youtube.com/watch?v=k2v3gxtMlDE)
- SliverAppBar
- SliverPersistantHeader
- SliverList
- SliverGrid
- SliverToBoxAdaptor
- SliverFillReamining 

Constraints:
- In Depth Explanation with Examples: (https://docs.flutter.dev/ui/layout/constraints)
- Flutter needs to perform layout quickly - needs to efficiently decide where to put Widgets on the screen
- Therefore Flutter's layout algorithm is single pass - contraints (e.g. padding) go down and geometry (size) goes up
- This happens to every widget - starts at top of tree and goes down to every leaf node (with contraints) and then back up to (with geometry)
- It gets more interesting with Widgets with multiple children (e.g. Column)
- This is where issues can arise e.g. if one of the children is a ListView (which is greedy and will take as much space as possible)
- This will give:
- 1) an error, or
- 2) an unwanted UI behaviour, or
- 3) cause a multi-pass algorithm which is much slower
- Fix by being as explicit as possible - e.g. wrap in Expanded(), or Flexible(), or SizedBox()

Basic Responsive Layouts:
- Guide: https://blog.codemagic.io/building-responsive-applications-with-flutter/
- Can be a challenge to adapt your app to a variety of screen sizes and pixel densities using the same codebase
- No hard and fast rules for designing a responsive layout in Flutter
- Android and iOS handle responsiveness differently - but Flutter handles this
- 1) MediaQuery - retrieves the size and orientation of the screen - is a property access
- 2) LayoutBuilder - allows you to get BoxConstaints object, which can be used to determine the maxWidth and maxHeight of the widget 
- 3) OrientationBuilder - to determine a widget's custom orientation, you can use the OrientationBuilder class - is a Widget
- 4) Exapnded and Flexible - Expanded widgets expands a child of Row, Column, or Flex so that the child fills all avaliable space, Flexible does not have to
- 5) FractionallySizedBox - helps to size its child to a fraction of the total avaliable space
- 6) Aspect Ratio - size the child to a specific aspect ratio - widget first tries to largest width permitted by the layout constaints and then decides height by applying given aspect ratio
- Split View Guide: https://codewithandrea.com/articles/flutter-responsive-layouts-split-view-drawer-navigation/
- Split View (large screens) and Drawer Navigation (Mobile) - creates different views depending on the scren size - can use a threshold for window width

Complex Responsive Layout Packages:
- layout (https://pub.dev/packages/layout)
- responsive_builder (https://pub.dev/packages/responsive_builder)

Adaptive Response:
- https://docs.flutter.dev/ui/adaptive-responsive

Theming:
- Important to create a cohesive design by sharing colours and font styles
- How to esnure all colours and styles are applieid consistently across all the pages in your app?
- Use Flutter's theming system by following 2 main steps:
- 1) Creating an app theme by setting tht etheme property of the MaterialApp constructor
- 2) Apply the theme by using Theme.of(context) when specifying a widget's styling properties
- Android and iOS have different design systems - Android uses Material 3, iOS uses Cupertino - Flutter apps are adaptive by default - they follow the look and feel of the platform they are running in
- More information about automatic platform adaptions: https://docs.flutter.dev/ui/adaptive-responsive/platform-adaptations
- Desgining a Flutter UI Documentation: https://docs.flutter.dev/reference/learning-resources#designing-a-flutter-ui
- Material 3: https://docs.flutter.dev/ui/design/material
- Theme Extensions: https://www.youtube.com/watch?v=8-szcYzFVao  

- To share colours and fonts throughout an app, use themes
- Can define app-wide themes, you can extend a theme to change a theme style for one component
- Each theme defines the colours, type style, and other parameters applicable for the type of Material component
- Flutter applies styling in the following order:
- 1) Styles applied to specific widget
- 2) Themes that override the immediate parent theme
- 3) Main theme for the entire app
- After you define Theme, use it wthin your own widgets, Flutter's Material widgets use your theme to set the background colours and font styles for visual widgets
- 1) Create an App Theme: set the theme propety to your MaterialApp constructor - takes a ThemeData instance with properties colorScheme and textTheme
- 2) Apply a Theme: use the Theme.of(context) method when specifying a widget's styling properties, e.g. style, color. Looks up the widget tree and retrieves the nearest Theme in the tree
- 3) Override a Theme: to override the overall theme, wrap that section in a Theme widget, either by creating a unique ThemeData instance, or extending the parent theme

State Management Basics:
- Flutter is a declarative framework that builds the UI to reflect the current state of your app:
- UI = f(state)
- App State vs Local (Ephemeral) State:
- State of an app is everything that exists in memory when the app is running, including assets, variables, animation state, textures, fonts, etc.
- Framework handles some states (e.g. textures)
- State = Whatever data you need in order to rebuild your UI at any moment in time
- The state that you do manage yourself can be separated into two conceptual types: Ephemeral (Local / UI) and App State

- Local State:
- State you can neatly contain in a single widget, intentionally a vague definition, e.g. current page in PageView, current progress of a complex animation, current selected tab in a BottomNavigationBar
- Other parts of the widget tree seldom need to access this kind of state - there is no need to serialise it and doesn't change in complex ways
- No need to use state management techniques on this kind of state - all you need is a StatefulWidget
- Using setState() and a field inside the StatefulWidget's State is completely natural - no other part of your app needs access to the variables within that widget
- If the user closes and restarts the app, the local varaibles reset

- App State:
- State that you want to share across many parts of your app, and you want to keep between user sessions, is called App State
- Examples: user preferences, login info, notifications in a social networking app, shopping cart in e-commerce app, read/unread state of articles in a news app
- For managing app state, you want to research your options

- No Clear Cut Rule:
- You can use State and setState() to manage all the states in your app
- Goes the other way, might need lots of things to be an app state 
- No universal rule to distinguish local vs app state
- In general:
- Single widget = local state 
- Some widgets / most widgets = app state

- InheritedWidget = Can share states across multiple widgets via scoped access
- ValueNotifier = Can store your state outside your widgets
- ValueListenableBuilder = use with ValueNotifier to update the UI when the state changes
- ChangeNotifier = "cousin" of ValueNotifier
- FutureBuilder & StreamBuilder = many asynchronous APIs use Futures and Streams to notify your app when new data is avaliable
- A Future produces a single asynchronous value, while a Stream can produce many asynchronous values over time
- Use FutureBuilder / StreamBuilder to decide what widget to show depending on the state of the Future (loading / data / error) / Stream (data, no data, error, loading)
- State Management Docs: https://docs.flutter.dev/data-and-backend/state-mgmt/simple

- StatelessWidget is composed of children and does not have any mutable state that it needs to track
- Mutable state is a property that would change over time e.g. textbox that changes text, widget that is animated
- A StatelessWidget has none of that
- Can use final (assigned once at runtime) for widgets that don't cahnge after being set
- Can use const (compile-time constant) for widgets and fields that can be fully known at compile time
- All StatelessWidget can use finals but not all can use const - if it can't use finals then it should be a StatefulWidget as fields change during run time
- StatelessWidget can't track data over time or trigger rebuilds over time

- StatefulWidgets provides mutable configuration information and a state object that can change over time and trigger rebuilds to the UI
- 2 Trees: Widget and Element Tree, ElementTree is actully what represent what's on screen and the widgets are just blueprints for those elements  
- For StatelessWidget, it's simple and a StatelessElement is created using the StatelessWidget blueprint
- With a StatefulWidget, there's an extra step, where the element also creates a State objet using the Widget blueprint
- Use the setState() method in the State object to make a change - allows you to set updates in the State object and make updates to the UI
- Every time a State object is updated, this is marked and the UI is updated in the next frame 
- Child widgets are then updated as State is updated
- Even if the parent widget has been replaced, if the child widget is of the same type, then this is maintained

- When app gets larger and widget tree gets more complex passing and accessing data can get cumbersome 
- If you have a large amount of nested widgets, and you need to pass data from the top to the bottom, you'll have to pass it through all the inbetween constructors and build methods of the widgets between
- You can use InheritedWidget to circumvent this - when you place an InheritedWidget at the top of the tree, any child widget can access it directly
- InheritedWidget is immutable

- Key parameters on Widgets
- Keys preserve States when widgets move around in the widget tree
- Can be used to preserve the user's scroll locaiton, or keeping state when modifying a collection
- When to Use Keys: 
- If you find yourself adding, removing or reordering a collection of widgets of the same type that hold the same state - then use keys 
- However, if the entire widget subtree in your collection is Stateless, then keys aren't needed
- This covers most your situations
- How Keys Work: 
- Element tree only holds information about the type of each widget - and a reference of child elements - shows the structure without the details - this is in the reference to the widget 
- When a widget tree is updated, it checks to see if the element tree matches not only the type but the key too - if so then it is updated. if a key isn't used the types match and therefore the element tree isn't updated even if the state has changed
- Where to Put Keys: 
- When matching widgets to elements, Flutter only looks for a key that matches at a certain level in the tree and if it's not there then it initialises a new state
- Types of Keys:  
- Value Key: compares equality based on a value you provide (like a string or number)
- Object Key: compares objects by identity (using ==) like when you have a complex model object
- Unique Key: always unique, even if created with the same data, forces Flutter to treat the widget as completely new every rebuild
- Global Key: most powerful and heaviest type - identities a widget globally across the entire app - not just among siblings - lets you access a widget's state or context directly

State Management Packages & App Architecture:
- Once you're confident with built in state management APIs in Flutter, you can look at 3rd party solutions
- Most stable, well-documented, maintained, and supported packages: provider, flutter_bloc, riverpod
- Only need one of these

- Provider:
- Provider = InheritedWidget + Generics
- Gives you scoped access to things in your widget tree by type

- flutter_bloc:
- Similar to Provider

- Riverpod:
- Reactive caching and data-bindin framework that evolved from Provider
- Does not depend on Flutter and widget tree
- Uses global providers that are references by name, not by type
- Allows you to manage state in complex applications in a type-safe way with minimal boilerplate code
- Great support for testing and works well when combining providers together

- Which Package is Best?
- Help you separate business logic from the UI code
- Comparison: https://github.com/bizz84/movie_app_state_management_flutter

- App Architecture:
- State managment solutions above are tools that you can use to build your apps
- When building complex apps, choosing the correct app architecture is crucial, as it allows you to structure your coe and support your codebase as it grows
- Good app architecture: https://codewithandrea.com/articles/flutter-app-architecture-riverpod-introduction/
- If we want to create complex apps with many pages and features, we should decide how to structure our project
- This ensures the entire team can follow a clear convention and add features in a consistent manner
- 2 Main Project Structures: Feature-First or Layer-First
- Comparison: https://codewithandrea.com/articles/flutter-project-structure/

Questions:
- How do you design software hierarchies - e.g. particular software
- What state management systems do you use?
- 