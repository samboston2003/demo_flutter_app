Flutter Basics:
- Flutter is a multi-platform toolkit, can run on iOS, Android, Windows, macOS, Linux, web
- "Development Target" = OS your apps run on during development
- Flutter's most useful development feature is "Stateful Hot Reload"
- Flutter 3.35.6 // Dart 3.9.2 // Java 19.0.2
- command palette = f1
- select device = bottom right of screen "No Device"
- run with debugging = top right arrow
- hot reload by saving file - will update app without having to restart program
- Flutter makes use of trailing commas - good idea to use as they make adding more members trivial - also hep Dart's auto-formatter to work
- having separate widgets for separate logical parts of your UI is an important way of managing complexity in Flutter
- Refactor menu = 'Ctrl + .' whilst selecting the piece of code you want to refactor - can extract / wrap
- Dart is null-safe so won't let you call methods of objects that are potentially null - '!' (bang operator) assures Dart you kno what you're doing
- to access ful list of changeable properties - place cusor within () and hit Ctrl + Shift + Space
- use Widget Inspector whilst debugging to see where widgets extend to (e.g. a column) - can then use the Refactor menu to add a Centre
- MyAppState previously covered all state needs - all the widgets were stateless - they don't contain a mutable state of their own - none of the widgets could change iteslf - must go through MyAppState
- can keep adding properties to MyAppState - but the class would grow beyond reason
- some state is only relevant to a single widget - so it should stay with that widget - hence you can use a StatefulWidget - a widget with a state
- can use the Refactor menu to convert a StatelessWidget > StatefulWidget
- Flutter works with logical pixels as a unit of length (device independent pixels)

Dart Notes:
- Everything you can place in a varialbe is an object, and every object is an instance of a class
- Dart is strongly typed, type annotations are optional because Dart can infer types (e.g. using var)
- If you enable null safety, variables can't contain null unless specified
- When you want to explicitly say that any type is allowed - use the type Object? or Object
- Dart supports generic types, like List<int> or List<Object>
- Dart supports top-level functions (such as main()), as well as functions tied to a class or object (static and instance methods respectively). Can also create functions within functions (nested / local)
- Dart support top-level variables, as well as variables tied to a class or object (static and instance varaibles) - instance variable sometimes known as fields / properties
- Dart doesn't have keywords 'public', 'protected', and 'private' - use the underscore (_) before an indentifier to make it private
- Indentifiers can start with a letter or underscore
- Dart has both expressions (which have runtime values) and statements (which don't)
- Dart tools can report 2 kinds of problems: warnings and errors
- Warnings are indictors that your code might not work, but don't prevent your programs from executing
- Errors can be either compile-time or run-time. A compile-time error prevents the code from executing atall. A run-time error results in an exception being raised while the code executes

Dart Guide:
- Effective Dart: https://dart.dev/effective-dart (style guide, documentation guide, usage guide, design guide) 

Flutter Command Line:
- flutter pub get - fetches the packages your project depends on
- reads the pubspec.yaml file
- downloads the necessary packcages from pub.dev
- saves the exact versions in pubspec.lock so your project is reproducible
- puts the packcages in your local cache for Flutter and Dart to use

- flutter pub upgrade - tries to upgrade your dependcies to the latest versions allowed by your version contraints in pubspec.yaml
- fetches newer compatible versions than what's currently in pubspec.lock
- updated pubspec.lock to reflect these newer versions

Git Command line:
- git status
- git add <file_name> or '.' for all
- git commit -m "message"
- git push

Flutter Widgets:
- Build UIs using widgets and composing them together in a declarative manner
- Flutter offers an extensive set of widgets the closely match the Material Design (https://docs.flutter.dev/ui/widgets/material) specification
- Flutter controls every pixel on the screen, can create your own widgets

Build Context:
- A Widget doesn't know where it is in regard to other widgets in the Widget tree
- Element = information needed at runtime for this widget in this part of the app - all in an Element tree - all in reference to the Widget that they represent
- An Element is a type of context 
- Allows widget to figure out where it is, gives the widget build method the context it needs

Widgets vs Helper Methods:
- UI is made from wrapping Widgets in other Widgets
- Eventually, this build method becomes very large and needs breaking up
- First step is to make a judgement call - picking which codeblocks are good candidates for re use
- E.g. repeated sequences of code and discrete sections of actual UI, in other words things that are contained and / or repeat
- How to move the code? 
- 1) Is to move the code into a method in the same widget (helper method option) 
- 2) Similar, but instead of moving codeblock to method in same widet, move it into an entirely new widget
- Helper Methods have downsides 
- 1) Performance: when SetState() is called from within a widget, it's entire build method is re run, which is inefficient to rebuild whole sections of UI - so instead of using helper method - use an entire new widget so Flutter can target rebuilds, using const constructors is even more efficient
- 2) Testability: writing test on a separate widget is simple, however with helper methods, you're required to construct alot of irrelevant widgets
- 3) Accuracy: with helper methods, it's possible that stale build contexts are used - but with widgets, you can prevent this
- Overall, deafult to classes over methods - there's no functional benefit to methods other than ease of writing code 

Layouts in Flutter:
- Everything is a Widget, including layout models (e.g. rows, columns, grids that arrange, constaiin and align visible wigets - create a layout by composing widgets to build more complex widgets)
- Container is a widget that allows you to customise its child widget - use a Container when you want to, for example add padding, margins, borders, or background colour 
- Contnrol the rest of the UI with Widget's properties e.g. Icon's colour with 'color', Text's properties with 'Text.style', Column's properties for alignment and space
- Set 'debugPaintSizeEnabled' to true to see the visual layout of widgets (borders)

Lay Out a Widget:
- 1) Select a layout widget - based on how you want to align or constrain a visible widget e.g. Center()
- 2) Create a visible widget - e.g. Text()
- 3) Add visible widget to the layout widget - all layout widgets have either of the following: 1) a child property if they take a single child e.g. Center, Container 2) a children property is they take a list of widgets e.g. Row, Column, ListView, Stack
- 4) Add the layouut widget to the page - instantiating and returning a widget in the app's build() method displays the widget
- for a genneral app, you can add the Container widget to the app's build() method
- for a Material app, you can use a Scaffoold widget - it proviides a default banner, background colour, and has API for adding drawers, snack bars, and bottom sheets - can add the Center() widget diretly to the body property for the home page

Choosing Widgets
- Can use Flutter Widget of the week (https://www.youtube.com/watch?v=b_sQ9bMltGU&list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG)

Most Useful Layout Widgets: 
- (https://www.youtube.com/watch?v=RJEnTRBxaSg) 
- (https://www.youtube.com/watch?v=-zJ6CnOVndE)
- Row
- Column
- Stack
- Expanded
- Padding
- PageView
- ListView
- GridView
- Slivers
- CustomScrollView

More Complex Sliver Layouts: 
- (https://www.youtube.com/watch?v=E3-WdYBrEDc) 
- (https://www.youtube.com/watch?v=k2v3gxtMlDE)
- SliverAppBar
- SliverPersistantHeader
- SliverList
- SliverGrid
- SliverToBoxAdaptor
- SliverFillReamining 

Constraints:
- In Depth Explanation with Examples: (https://docs.flutter.dev/ui/layout/constraints)
- Flutter needs to perform layout quickly - needs to efficiently decide where to put Widgets on the screen
- Therefore Flutter's layout algorithm is single pass - contraints (e.g. padding) go down and geometry (size) goes up
- This happens to every widget - starts at top of tree and goes down to every leaf node (with contraints) and then back up to (with geometry)
- It gets more interesting with Widgets with multiple children (e.g. Column)
- This is where issues can arise e.g. if one of the children is a ListView (which is greedy and will take as much space as possible)
- This will give:
- 1) an error, or
- 2) an unwanted UI behaviour, or
- 3) cause a multi-pass algorithm which is much slower
- Fix by being as explicit as possible - e.g. wrap in Expanded(), or Flexible(), or SizedBox()

Basic Responsive Layouts:
- Guide: https://blog.codemagic.io/building-responsive-applications-with-flutter/
- Can be a challenge to adapt your app to a variety of screen sizes and pixel densities using the same codebase
- No hard and fast rules for designing a responsive layout in Flutter
- Android and iOS handle responsiveness differently - but Flutter handles this
- 1) MediaQuery - retrieves the size and orientation of the screen - is a property access
- 2) LayoutBuilder - allows you to get BoxConstaints object, which can be used to determine the maxWidth and maxHeight of the widget 
- 3) OrientationBuilder - to determine a widget's custom orientation, you can use the OrientationBuilder class - is a Widget
- 4) Exapnded and Flexible - Expanded widgets expands a child of Row, Column, or Flex so that the child fills all avaliable space, Flexible does not have to
- 5) FractionallySizedBox - helps to size its child to a fraction of the total avaliable space
- 6) Aspect Ratio - size the child to a specific aspect ratio - widget first tries to largest width permitted by the layout constaints and then decides height by applying given aspect ratio
- Split View Guide: https://codewithandrea.com/articles/flutter-responsive-layouts-split-view-drawer-navigation/
- Split View (large screens) and Drawer Navigation (Mobile) - creates different views depending on the scren size - can use a threshold for window width

Complex Responsive Layout Packages:
- layout (https://pub.dev/packages/layout)
- responsive_builder (https://pub.dev/packages/responsive_builder)

Adaptive Response:
- https://docs.flutter.dev/ui/adaptive-responsive

Theming:
- Important to create a cohesive design by sharing colours and font styles
- How to esnure all colours and styles are applieid consistently across all the pages in your app?
- Use Flutter's theming system by following 2 main steps:
- 1) Creating an app theme by setting tht etheme property of the MaterialApp constructor
- 2) Apply the theme by using Theme.of(context) when specifying a widget's styling properties
- Android and iOS have different design systems - Android uses Material 3, iOS uses Cupertino - Flutter apps are adaptive by default - they follow the look and feel of the platform they are running in
- More information about automatic platform adaptions: https://docs.flutter.dev/ui/adaptive-responsive/platform-adaptations
- Desgining a Flutter UI Documentation: https://docs.flutter.dev/reference/learning-resources#designing-a-flutter-ui
- Material 3: https://docs.flutter.dev/ui/design/material
- Theme Extensions: https://www.youtube.com/watch?v=8-szcYzFVao  

- To share colours and fonts throughout an app, use themes
- Can define app-wide themes, you can extend a theme to change a theme style for one component
- Each theme defines the colours, type style, and other parameters applicable for the type of Material component
- Flutter applies styling in the following order:
- 1) Styles applied to specific widget
- 2) Themes that override the immediate parent theme
- 3) Main theme for the entire app
- After you define Theme, use it wthin your own widgets, Flutter's Material widgets use your theme to set the background colours and font styles for visual widgets
- 1) Create an App Theme: set the theme propety to your MaterialApp constructor - takes a ThemeData instance with properties colorScheme and textTheme
- 2) Apply a Theme: use the Theme.of(context) method when specifying a widget's styling properties, e.g. style, color. Looks up the widget tree and retrieves the nearest Theme in the tree
- 3) Override a Theme: to override the overall theme, wrap that section in a Theme widget, either by creating a unique ThemeData instance, or extending the parent theme

State Management Basics:
- Flutter is a declarative framework that builds the UI to reflect the current state of your app:
- UI = f(state)
- App State vs Local (Ephemeral) State:
- State of an app is everything that exists in memory when the app is running, including assets, variables, animation state, textures, fonts, etc.
- Framework handles some states (e.g. textures)
- State = Whatever data you need in order to rebuild your UI at any moment in time
- The state that you do manage yourself can be separated into two conceptual types: Ephemeral (Local / UI) and App State

- Local State:
- State you can neatly contain in a single widget, intentionally a vague definition, e.g. current page in PageView, current progress of a complex animation, current selected tab in a BottomNavigationBar
- Other parts of the widget tree seldom need to access this kind of state - there is no need to serialise it and doesn't change in complex ways
- No need to use state management techniques on this kind of state - all you need is a StatefulWidget
- Using setState() and a field inside the StatefulWidget's State is completely natural - no other part of your app needs access to the variables within that widget
- If the user closes and restarts the app, the local varaibles reset

- App State:
- State that you want to share across many parts of your app, and you want to keep between user sessions, is called App State
- Examples: user preferences, login info, notifications in a social networking app, shopping cart in e-commerce app, read/unread state of articles in a news app
- For managing app state, you want to research your options

- No Clear Cut Rule:
- You can use State and setState() to manage all the states in your app
- Goes the other way, might need lots of things to be an app state 
- No universal rule to distinguish local vs app state
- In general:
- Single widget = local state 
- Some widgets / most widgets = app state

- InheritedWidget = Can share states across multiple widgets via scoped access
- ValueNotifier = Can store your state outside your widgets
- ValueListenableBuilder = use with ValueNotifier to update the UI when the state changes
- ChangeNotifier = "cousin" of ValueNotifier
- FutureBuilder & StreamBuilder = many asynchronous APIs use Futures and Streams to notify your app when new data is avaliable
- A Future produces a single asynchronous value, while a Stream can produce many asynchronous values over time
- Use FutureBuilder / StreamBuilder to decide what widget to show depending on the state of the Future (loading / data / error) / Stream (data, no data, error, loading)
- State Management Docs: https://docs.flutter.dev/data-and-backend/state-mgmt/simple

Questions:
- Particular software to create widget hierarchies