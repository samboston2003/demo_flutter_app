Flutter Basics:
- Flutter is a multi-platform toolkit, can run on iOS, Android, Windows, macOS, Linux, web
- "Development Target" = OS your apps run on during development
- Flutter's most useful development feature is "Stateful Hot Reload"
- Flutter 3.35.6 // Dart 3.9.2 // Java 19.0.2
- command palette = f1
- select device = bottom right of screen "No Device"
- run with debugging = top right arrow
- hot reload by saving file - will update app without having to restart program
- Flutter makes use of trailing commas - good idea to use as they make adding more members trivial - also hep Dart's auto-formatter to work
- having separate widgets for separate logical parts of your UI is an important way of managing complexity in Flutter
- Refactor menu = 'Ctrl + .' whilst selecting the piece of code you want to refactor - can extract / wrap
- Dart is null-safe so won't let you call methods of objects that are potentially null - '!' (bang operator) assures Dart you kno what you're doing
- to access ful list of changeable properties - place cusor within () and hit Ctrl + Shift + Space
- use Widget Inspector whilst debugging to see where widgets extend to (e.g. a column) - can then use the Refactor menu to add a Centre
- MyAppState previously covered all state needs - all the widgets were stateless - they don't contain a mutable state of their own - none of the widgets could change iteslf - must go through MyAppState
- can keep adding properties to MyAppState - but the class would grow beyond reason
- some state is only relevant to a single widget - so it should stay with that widget - hence you can use a StatefulWidget - a widget with a state
- can use the Refactor menu to convert a StatelessWidget > StatefulWidget
- Flutter works with logical pixels as a unit of length (device independent pixels)

Dart Notes:
- Everything you can place in a varialbe is an object, and every object is an instance of a class
- Dart is strongly typed, type annotations are optional because Dart can infer types (e.g. using var)
- If you enable null safety, variables can't contain null unless specified
- When you want to explicitly say that any type is allowed - use the type Object? or Object
- Dart supports generic types, like List<int> or List<Object>
- Dart supports top-level functions (such as main()), as well as functions tied to a class or object (static and instance methods respectively). Can also create functions within functions (nested / local)
- Dart support top-level variables, as well as variables tied to a class or object (static and instance varaibles) - instance variable sometimes known as fields / properties
- Dart doesn't have keywords 'public', 'protected', and 'private' - use the underscore (_) before an indentifier to make it private
- Indentifiers can start with a letter or underscore
- Dart has both expressions (which have runtime values) and statements (which don't)
- Dart tools can report 2 kinds of problems: warnings and errors
- Warnings are indictors that your code might not work, but don't prevent your programs from executing
- Errors can be either compile-time or run-time. A compile-time error prevents the code from executing atall. A run-time error results in an exception being raised while the code executes

Dart Guide:
- Effective Dart: https://dart.dev/effective-dart (style guide, documentation guide, usage guide, design guide) 

Flutter Command Line:
- flutter pub get - fetches the packages your project depends on
- reads the pubspec.yaml file
- downloads the necessary packcages from pub.dev
- saves the exact versions in pubspec.lock so your project is reproducible
- puts the packcages in your local cache for Flutter and Dart to use

- flutter pub upgrade - tries to upgrade your dependcies to the latest versions allowed by your version contraints in pubspec.yaml
- fetches newer compatible versions than what's currently in pubspec.lock
- updated pubspec.lock to reflect these newer versions

Git Command line:
- git status
- git add <file_name> or '.' for all
- git commit -m "message"
- git push

Flutter Widgets:
- Build UIs using widgets and composing them together in a declarative manner
- Flutter offers an extensive set of widgets the closely match the Material Design (https://docs.flutter.dev/ui/widgets/material) specification
- Flutter controls every pixel on the screen, can create your own widgets

Build Context:
- A Widget doesn't know where it is in regard to other widgets in the Widget tree
- Element = information needed at runtime for this widget in this part of the app - all in an Element tree - all in reference to the Widget that they represent
- An Element is a type of context 
- Allows widget to figure out where it is, gives the widget build method the context it needs

Widgets vs Helper Methods:
- UI is made from wrapping Widgets in other Widgets
- Eventually, this build method becomes very large and needs breaking up
- First step is to make a judgement call - picking which codeblocks are good candidates for re use
- E.g. repeated sequences of code and discrete sections of actual UI, in other words things that are contained and / or repeat
- How to move the code? 
- 1) Is to move the code into a method in the same widget (helper method option) 
- 2) Similar, but instead of moving codeblock to method in same widet, move it into an entirely new widget
- Helper Methods have downsides 
- 1) Performance: when SetState() is called from within a widget, it's entire build method is re run, which is inefficient to rebuild whole sections of UI - so instead of using helper method - use an entire new widget so Flutter can target rebuilds, using const constructors is even more efficient
- 2) Testability: writing test on a separate widget is simple, however with helper methods, you're required to construct alot of irrelevant widgets
- 3) Accuracy: with helper methods, it's possible that stale build contexts are used - but with widgets, you can prevent this
- Overall, deafult to classes over methods - there's no functional benefit to methods other than ease of writing code 

Layouts in Flutter:
- Everything is a Widget, including layout models (e.g. rows, columns, grids that arrange, constaiin and align visible wigets - create a layout by composing widgets to build more complex widgets)
- Container is a widget that allows you to customise its child widget - use a Container when you want to, for example add padding, margins, borders, or background colour 
- Contnrol the rest of the UI with Widget's properties e.g. Icon's colour with 'color', Text's properties with 'Text.style', Column's properties for alignment and space
- Set 'debugPaintSizeEnabled' to true to see the visual layout of widgets (borders)

Lay Out a Widget:
- 1) Select a layout widget - based on how you want to align or constrain a visible widget e.g. Center()
- 2) Create a visible widget - e.g. Text()
- 3) Add visible widget to the layout widget - all layout widgets have either of the following: 1) a child property if they take a single child e.g. Center, Container 2) a children property is they take a list of widgets e.g. Row, Column, ListView, Stack
- 4) Add the layouut widget to the page - instantiating and returning a widget in the app's build() method displays the widget
- for a genneral app, you can add the Container widget to the app's build() method
- for a Material app, you can use a Scaffoold widget - it proviides a default banner, background colour, and has API for adding drawers, snack bars, and bottom sheets - can add the Center() widget diretly to the body property for the home page

Choosing Widgets
- Can use Flutter Widget of the week (https://www.youtube.com/watch?v=b_sQ9bMltGU&list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG)

Most Useful Layout Widgets: 
- (https://www.youtube.com/watch?v=RJEnTRBxaSg) 
- (https://www.youtube.com/watch?v=-zJ6CnOVndE)
- Row
- Column
- Stack
- Expanded
- Padding
- PageView
- ListView
- GridView
- Slivers
- CustomScrollView

More Complex Sliver Layouts: 
- (https://www.youtube.com/watch?v=E3-WdYBrEDc) 
- (https://www.youtube.com/watch?v=k2v3gxtMlDE)
- SliverAppBar
- SliverPersistantHeader
- SliverList
- SliverGrid
- SliverToBoxAdaptor
- SliverFillReamining 

Constraints:
- In Depth Explanation with Examples: (https://docs.flutter.dev/ui/layout/constraints)
- Flutter needs to perform layout quickly - needs to efficiently decide where to put Widgets on the screen
- Therefore Flutter's layout algorithm is single pass - contraints (e.g. padding) go down and geometry (size) goes up
- This happens to every widget - starts at top of tree and goes down to every leaf node (with contraints) and then back up to (with geometry)
- It gets more interesting with Widgets with multiple children (e.g. Column)
- This is where issues can arise e.g. if one of the children is a ListView (which is greedy and will take as much space as possible)
- This will give:
- 1) an error, or
- 2) an unwanted UI behaviour, or
- 3) cause a multi-pass algorithm which is much slower
- Fix by being as explicit as possible - e.g. wrap in Expanded(), or Flexible(), or SizedBox()

Basic Responsive Layouts:
- Guide: https://blog.codemagic.io/building-responsive-applications-with-flutter/
- Can be a challenge to adapt your app to a variety of screen sizes and pixel densities using the same codebase
- No hard and fast rules for designing a responsive layout in Flutter
- Android and iOS handle responsiveness differently - but Flutter handles this
- 1) MediaQuery - retrieves the size and orientation of the screen - is a property access
- 2) LayoutBuilder - allows you to get BoxConstaints object, which can be used to determine the maxWidth and maxHeight of the widget 
- 3) OrientationBuilder - to determine a widget's custom orientation, you can use the OrientationBuilder class - is a Widget
- 4) Exapnded and Flexible - Expanded widgets expands a child of Row, Column, or Flex so that the child fills all avaliable space, Flexible does not have to
- 5) FractionallySizedBox - helps to size its child to a fraction of the total avaliable space
- 6) Aspect Ratio - size the child to a specific aspect ratio - widget first tries to largest width permitted by the layout constaints and then decides height by applying given aspect ratio
- Split View Guide: https://codewithandrea.com/articles/flutter-responsive-layouts-split-view-drawer-navigation/
- Split View (large screens) and Drawer Navigation (Mobile) - creates different views depending on the scren size - can use a threshold for window width

Complex Responsive Layout Packages:
- layout (https://pub.dev/packages/layout)
- responsive_builder (https://pub.dev/packages/responsive_builder)

Adaptive Response:
- https://docs.flutter.dev/ui/adaptive-responsive

Theming:
- Important to create a cohesive design by sharing colours and font styles
- How to esnure all colours and styles are applieid consistently across all the pages in your app?
- Use Flutter's theming system by following 2 main steps:
- 1) Creating an app theme by setting tht etheme property of the MaterialApp constructor
- 2) Apply the theme by using Theme.of(context) when specifying a widget's styling properties
- Android and iOS have different design systems - Android uses Material 3, iOS uses Cupertino - Flutter apps are adaptive by default - they follow the look and feel of the platform they are running in
- More information about automatic platform adaptions: https://docs.flutter.dev/ui/adaptive-responsive/platform-adaptations
- Desgining a Flutter UI Documentation: https://docs.flutter.dev/reference/learning-resources#designing-a-flutter-ui
- Material 3: https://docs.flutter.dev/ui/design/material
- Theme Extensions: https://www.youtube.com/watch?v=8-szcYzFVao  

- To share colours and fonts throughout an app, use themes
- Can define app-wide themes, you can extend a theme to change a theme style for one component
- Each theme defines the colours, type style, and other parameters applicable for the type of Material component
- Flutter applies styling in the following order:
- 1) Styles applied to specific widget
- 2) Themes that override the immediate parent theme
- 3) Main theme for the entire app
- After you define Theme, use it wthin your own widgets, Flutter's Material widgets use your theme to set the background colours and font styles for visual widgets
- 1) Create an App Theme: set the theme propety to your MaterialApp constructor - takes a ThemeData instance with properties colorScheme and textTheme
- 2) Apply a Theme: use the Theme.of(context) method when specifying a widget's styling properties, e.g. style, color. Looks up the widget tree and retrieves the nearest Theme in the tree
- 3) Override a Theme: to override the overall theme, wrap that section in a Theme widget, either by creating a unique ThemeData instance, or extending the parent theme

State Management Basics:
- Flutter is a declarative framework that builds the UI to reflect the current state of your app:
- UI = f(state)
- App State vs Local (Ephemeral) State:
- State of an app is everything that exists in memory when the app is running, including assets, variables, animation state, textures, fonts, etc.
- Framework handles some states (e.g. textures)
- State = Whatever data you need in order to rebuild your UI at any moment in time
- The state that you do manage yourself can be separated into two conceptual types: Ephemeral (Local / UI) and App State

- Local State:
- State you can neatly contain in a single widget, intentionally a vague definition, e.g. current page in PageView, current progress of a complex animation, current selected tab in a BottomNavigationBar
- Other parts of the widget tree seldom need to access this kind of state - there is no need to serialise it and doesn't change in complex ways
- No need to use state management techniques on this kind of state - all you need is a StatefulWidget
- Using setState() and a field inside the StatefulWidget's State is completely natural - no other part of your app needs access to the variables within that widget
- If the user closes and restarts the app, the local varaibles reset

- App State:
- State that you want to share across many parts of your app, and you want to keep between user sessions, is called App State
- Examples: user preferences, login info, notifications in a social networking app, shopping cart in e-commerce app, read/unread state of articles in a news app
- For managing app state, you want to research your options

- No Clear Cut Rule:
- You can use State and setState() to manage all the states in your app
- Goes the other way, might need lots of things to be an app state 
- No universal rule to distinguish local vs app state
- In general:
- Single widget = local state 
- Some widgets / most widgets = app state

- InheritedWidget = Can share states across multiple widgets via scoped access
- ValueNotifier = Can store your state outside your widgets
- ValueListenableBuilder = use with ValueNotifier to update the UI when the state changes
- ChangeNotifier = "cousin" of ValueNotifier
- FutureBuilder & StreamBuilder = many asynchronous APIs use Futures and Streams to notify your app when new data is avaliable
- A Future produces a single asynchronous value, while a Stream can produce many asynchronous values over time
- Use FutureBuilder / StreamBuilder to decide what widget to show depending on the state of the Future (loading / data / error) / Stream (data, no data, error, loading)
- State Management Docs: https://docs.flutter.dev/data-and-backend/state-mgmt/simple

- StatelessWidget is composed of children and does not have any mutable state that it needs to track
- Mutable state is a property that would change over time e.g. textbox that changes text, widget that is animated
- A StatelessWidget has none of that
- Can use final (assigned once at runtime) for widgets that don't cahnge after being set
- Can use const (compile-time constant) for widgets and fields that can be fully known at compile time
- All StatelessWidget can use finals but not all can use const - if it can't use finals then it should be a StatefulWidget as fields change during run time
- StatelessWidget can't track data over time or trigger rebuilds over time

- StatefulWidgets provides mutable configuration information and a state object that can change over time and trigger rebuilds to the UI
- 2 Trees: Widget and Element Tree, ElementTree is actully what represent what's on screen and the widgets are just blueprints for those elements  
- For StatelessWidget, it's simple and a StatelessElement is created using the StatelessWidget blueprint
- With a StatefulWidget, there's an extra step, where the element also creates a State objet using the Widget blueprint
- Use the setState() method in the State object to make a change - allows you to set updates in the State object and make updates to the UI
- Every time a State object is updated, this is marked and the UI is updated in the next frame 
- Child widgets are then updated as State is updated
- Even if the parent widget has been replaced, if the child widget is of the same type, then this is maintained

- When app gets larger and widget tree gets more complex passing and accessing data can get cumbersome 
- If you have a large amount of nested widgets, and you need to pass data from the top to the bottom, you'll have to pass it through all the inbetween constructors and build methods of the widgets between
- You can use InheritedWidget to circumvent this - when you place an InheritedWidget at the top of the tree, any child widget can access it directly
- InheritedWidget is immutable

- Key parameters on Widgets
- Keys preserve States when widgets move around in the widget tree
- Can be used to preserve the user's scroll locaiton, or keeping state when modifying a collection
- When to Use Keys: 
- If you find yourself adding, removing or reordering a collection of widgets of the same type that hold the same state - then use keys 
- However, if the entire widget subtree in your collection is Stateless, then keys aren't needed
- This covers most your situations
- How Keys Work: 
- Element tree only holds information about the type of each widget - and a reference of child elements - shows the structure without the details - this is in the reference to the widget 
- When a widget tree is updated, it checks to see if the element tree matches not only the type but the key too - if so then it is updated. if a key isn't used the types match and therefore the element tree isn't updated even if the state has changed
- Where to Put Keys: 
- When matching widgets to elements, Flutter only looks for a key that matches at a certain level in the tree and if it's not there then it initialises a new state
- Types of Keys:  
- Value Key: compares equality based on a value you provide (like a string or number)
- Object Key: compares objects by identity (using ==) like when you have a complex model object
- Unique Key: always unique, even if created with the same data, forces Flutter to treat the widget as completely new every rebuild
- Global Key: most powerful and heaviest type - identities a widget globally across the entire app - not just among siblings - lets you access a widget's state or context directly

State Management Packages & App Architecture:
- Once you're confident with built in state management APIs in Flutter, you can look at 3rd party solutions
- Most stable, well-documented, maintained, and supported packages: provider, flutter_bloc, riverpod
- Only need one of these

- Provider:
- Provider = InheritedWidget + Generics
- Gives you scoped access to things in your widget tree by type

- flutter_bloc:
- Similar to Provider

- Riverpod:
- Reactive caching and data-bindin framework that evolved from Provider
- Does not depend on Flutter and widget tree
- Uses global providers that are references by name, not by type
- Allows you to manage state in complex applications in a type-safe way with minimal boilerplate code
- Great support for testing and works well when combining providers together

- Which Package is Best?
- Help you separate business logic from the UI code
- Comparison: https://github.com/bizz84/movie_app_state_management_flutter

- App Architecture:
- State managment solutions above are tools that you can use to build your apps
- When building complex apps, choosing the correct app architecture is crucial, as it allows you to structure your coe and support your codebase as it grows
- Good app architecture: https://codewithandrea.com/articles/flutter-app-architecture-riverpod-introduction/
- If we want to create complex apps with many pages and features, we should decide how to structure our project
- This ensures the entire team can follow a clear convention and add features in a consistent manner
- 2 Main Project Structures: Feature-First or Layer-First
- Comparison: https://codewithandrea.com/articles/flutter-project-structure/

Navigation and Routing:
- Need to learn APIs so you can navigate between screens

- Navigator 1.0:

- Basic Navigation with Push/Pop:
- https://docs.flutter.dev/cookbook/navigation/navigation-basics
- 1) Getting a navigator object for the current context
- 2) Calling push() to add a new route to the navigation stack 
- 3) Calling pop() to return to the previous route once done 

- Basic Navigation with Named Routes:
- https://docs.flutter.dev/cookbook/navigation/named-routes
- Define a set of named routes so yuo can centralise all your routing logic in the same place

- Passing Argument to Named Routes:
- https://docs.flutter.dev/cookbook/navigation/navigate-with-arguments
- Once you're comfortable with named routes, the next thing you'll want to do is to pass arguments to them

- Navigator 2.0:

- Limitations of Navigator 1.0:
- Arbritrary changes to the navigation stack are hard because push() and pop() only apply to the topmost route
- Deep linking from push notifications is hard as it requires changing the tnrie navigation stack that is not practical using push() and pop()
- Restoring the app navigation state on app restart is hard for teh same reasons

- Navigator 2.0 solves these issues by introducing a declarativeAPI that is backwards compatible with the imperative API of Navigator 1.0
- However, Navigator 2.0 APIS were hard to use

- Other Naviagtion & Routing Packages:

- To overcome complexiity of Navigator 2.0, community has createdvarious packages that offer a simple API and make declarative navigation easy
- Most popular packages:
- go_router
- auto_route
- beamer

Bottom Line:
- Use 1.0 if your app only needs to perform simple navigation with push() and pop() (including named routes)
- Use 2.0 if you need to handle deep links, perform state restoration, or make arbritrary changes to the navigation stacks
- Use a good 3rd party package if you find Navigator 2.0 too complex, but still need a declarative API

Interactivity and User Input:

- Every app needs to deal with user Input
- Many details to consider:
- Input text validation
- Handling selected focus and dismissing keyboard when needed
- Getting and setting the text field's data and updating the form state
- Text field apperance (decoration. placeholder text, error hints, etc.)

- Can use TextField widgets, passing a TextEditingController as an argument to control the text inside of it, typically done within a StatefulWidget
- Howevver, if you have more than 1 text field on your page, you'll need a TextEditingController for each TextField, which can lead to alot of boilerplate
- Can use the built-in Form and FormTextField widgets (https://www.youtube.com/watch?v=OtIDk6-p3eQ)
- Learn more about Flutter forms (https://docs.flutter.dev/cookbook/forms)
- Learn more about TextField (https://medium.com/flutter-community/a-deep-dive-into-flutter-textfields-f0e676aaab7a)
- Learn about client-side validation (https://codewithandrea.com/articles/flutter-text-field-form-validation/)

- Working with TextEditingController can add alot of boilerplate to your apps
- flutter_hooks provides an elegant solution for this and comes with a useTextEditingController API that you can use to streamline your text editing code
- https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/useTextEditingController-constant.html

- Text input is just one of many ways that users can interact with an app
- Other common input widgets are date and time pickers, checkboxes, radio boxes, sliders, switches
- Listed in the Material Component Widgetes catalogue: https://docs.flutter.dev/ui/widgets/material#Input%20and%20selections

- All widgets above are visual UI components that can be shown on screen, but Flutter also gives you some rich APIs for detecting user geustures
- Overview for how to use geustures in Flutter: https://docs.flutter.dev/ui/interactivity/gestures
- Deep dive: https://medium.com/flutter-community/flutter-deep-dive-gestures-c16203b3434f 

Animations:

- Flutter offers some well designed APIs that make it easy to implement complex animations and make your apps stand out
- Introduction to animations: https://docs.flutter.dev/ui/animations
- Animation codelabs: https://docs.flutter.dev/ui/animations#codelabs-tutorials-and-articles
- Talk about Flutter's animation system: https://www.youtube.com/watch?v=FCyoHclCqc8

- Animation Packages:
- flutter_animate
- SpinKit
- animations
- Funvas
- Simple Animations
- Staggered Animations
- Spring
- Rive

- CodeWithAndrea - Flutter Animations Masterclass Full Course

Local Data Persistence:

- Data persistence is an important requiremnt for many differnet apps
- By saving data locally to the disk, you can retrieve it the next time the app is started and present it again

- Using a Key-Value Store:
- Use shared_preferences to store non-sensitive user data
- May include things like app preferences, settings, or a boolean flag to verify if the user has completed the app onboarding
- Another popular key-value store is Hive CE, which is cross-playform, has a simple and intuitive API, very fast, and has strong encryption built in

- Using a Secuer Key-Value Store:
- Senitive data such as the user's email and address should not be saved unencrypted
- When dealing with sensitive data, it's best to use a secure key-value store such as flutter_secure_storage
- This has an API that is very similar to shared preefrences but uses the underlying Keychain on iOS and KeyStore on Android

- Using a Relational Database (SQL): 
- Can use sqlflite, the SQLite plugin for Flutter
- Provides some asynchronous APIs for reading from and writing to a local database using SQL
- Not type safe, can lead to bugs that are hard to diagnose
- To solve this, Drift package was created
- Is type-safe reactive persistence library for Flutter and Dart, built on top of SQLite
- Drift has extensive documentation convering everything you need to know#
- Top Flutter Persistent SQL Database Pacakges: https://fluttergems.dev/sql-database/ 

- Using a NoSQL Database:
- Relational databases are very powerful and a robust choice for data persistance 
- Have a bit of learning curve, so cna start with some simpler NoSQL alternative, e.g. Isar, ObjectBox, or Realm
- Top Fluter Persistent NoSQL Database Packages: https://fluttergems.dev/nosql-database/

- Reading and Writing Files to disk
- Key-value stores and relational databases are great, but sometiime want to write data directly to files on disk
- Done by combining the path_providier plugin with the dart:io library

- Which Package to Use?
- shared_preferences for non sensitive data
- flutter_secure_storage for sensitive data
- drift for complex relational data and want both type-safety and SQL
- path_providier and dart:io for saving local files to disk
- API keys: https://codewithandrea.com/articles/flutter-api-keys-dart-define-env-files/

- Local vs Remote Data Persistence:
- Local data persistance is fine if you don't need to sync data across multiple devices
- With local persistance, users will lose their data if they move to a new device without backing it up
- Local data persistence tutorial: https://www.youtube.com/watch?v=uCbHxLA9t9E&feature=youtu.be
- Many apps need to access user-generated content that is saved remotely in the cloud
- In this case, you need to create your own backend using a Backend-as-a-Service, e.h Firebase, Supabase, AppWrite
- Firebase offers things like authentication. a real-timepersistent document store, cloud functuions, and many other useful features
- CodeWithAndrea Firebase Masterclass: https://codewithandrea.com/courses/flutter-firebase-masterclass/

Networking:

- Basics:
- If you want your apps to read data from public APIs for communicate with your own custom backend, you'll need to write some netwokring code
- Simple apps that ned to talk to a REST API can use the Dart http package
- Offers a Future-bsed AI for making network requests, and works on all platfroms since it's a pure Dart package
- Most REST APIs willr epond with data in JSON format, which can be decoded nto maps of key-value pairs that are not type safe
- When reading JSON data, best practice to deserialise and convert it into type-safe model classes
- Likewise, you can serialise your mosels back to JSON data that can be sent over the network
- Guide: https://codewithandrea.com/articles/parse-json-dart/

- Code Generation:
- If you have many endpoints returning complex data, code generation may be a better option, and the json_annotation package helps with that
- Can also consider using the freezed package
- Intro to code generation and freezed package: https://www.youtube.com/watch?v=pI6cXMmXBkA&feature=youtu.be

- Other Networking Packages:
- http package is easy to use and works well for simple apps
- For apps with more complex requirements, the dio package may be more appropiate 
- Dio supports more advanced features, such as sending form data, request cancellation, file downloading etc.
- Even then, still need to deal with JSON serialisation
- Retrofit can auto generate REST clients for all your models with minimal boiler plate code, that auto-generated all the netwroking and serialisation code for you
- Generate REST API clients in Dart from an API schema using OpenAPI: https://www.youtube.com/watch?v=WF1pd5bdtcI&feature=youtu.be

Flutter Platform Channels & Dart FFI:

- Single codebase, multiple platforms, is the biggest advantage of Flutter
- But sometimes, we need to use platform-specific APIs to access features such as camera input, geolocation, connectivity, and notifications
- Many packages that do the heavy lifting for you so you don't have to write platform-specific code by handle
- Still very useful and interesting to understand how Flutter apps communicate with the underlying platform APIs

- Platform Channels:
- To write platform specfic code, you'll need to become familiar wth Swift (iOS) and Kotlin (Andriod)
- This makes you a better developer who is comfortable with more than just one langauge or framework
- Don't need to be an expert, but knowing just enough to find your way around is a valuable skill as you may find yourself working with platform-specific APIs
- Guide on Writing Custom Platform Specific Code: https://docs.flutter.dev/platform-integration/platform-channels
- Guide on Flutter Platform Channels: https://blog.flutter.dev/flutter-platform-channels-ce7f540a104e

- Dart FFI:
- Platform channels are great for accessing platform-specific APIs
- But if you want to run performance critcal code that is written with a different langauge, such as C, C++, robust
- For this Dart defines a Foreign Function Interface, and this tutorial shows how: https://quickbirdstudios.com/blog/dart-swift-objective-c-interop/

Automated Testing:
- To build robust, production ready apps, verify code is bug free and behaves as expected with testing
- Manual tests: carried out by testing all your application's features by hand - very error prone and time-consuming and don't work at scale
- Automated tests: need to be written and maintained, but they run fast and often - good safety net that can help you find out if something breaks when you refactor your code

- Unit Tests, Widget Tests, Integration Tests:
- Official documentation: https://docs.flutter.dev/testing
- Quick tutorial with examples: https://www.youtube.com/watch?v=RDY6UYh-nyg&feature=youtu.be
- Covers how to use the mockito package, which is useful when testing individual parts of your application in isolatiion from the rest of the code (e.g. networking)
- With the introduction of Null Safety, mockito now relies on code generation and alot harder to use, so recommend using mocktail instead, offers the same API but doesn't require codegen
- More in dpeth couruse on testing fundamentals: https://www.youtube.com/playlist?list=PLprI2satkVdFwpxo_bjFkCxXz5RluG8FY 

- Golden Image Tests:
- Allows you to compare a screne if your app with some refernec image file, to ensure that each pixel in the UI matches exactly with the golden version
- Technique is quite useful if you want to verify that you don't get UI regressions as you make changes
- Use the golden_toolkit packcages
- Explanation article: https://medium.com/flutter-community/flutter-golden-tests-compare-widgets-with-snapshots-27f83f266cea

- Integration Tests with Patrol:
- Patrol is a new testing framework for Flutter
- Builds on top of Flutter's existing test toolkit, allowing you to access nattive platform featurues while extending the existing finder APIs, making them shorter and easier to understand
- Also works as a production quality of Flutter's built-in integration_test plugin by fixing some of its shortcomings and enabling features such as full isolation between tests and sharding
- Documentation: https://patrol.leancode.co/
- Video: https://www.droidcon.com/2023/08/07/reimagining-flutter-ui-tests-with-patrol/

Continious Inegration & Delivery:

- Tests are only useful if we run them regularly
- Most popular CI (Continious Integration) systems for Flutter are Codemagic and Gtihub applications
- These systems let you automate your test by setting up workflows that run when you want
- E.g. you could let them run your entire test suite when you push a new branch or open / update a pull request
- This is useful as you can ensure that all tests are green before merging changes to the main branch
- Can also use the CI tools to build release versions of your apps and deliver them to the App Store or Play Store
- Or, if you want to distribute internal builds to your beta testers, you can do that too

- Codemagic
- Easy to use
- Can set up and customise your workflows visually to add custom build steps and various 3rd party integrations
- E.g. can configure it to send a Slack notification when your builds succeed or familiar
-  Overview of Codemagic: https://blog.codemagic.io/7-reasons-to-use-codemagic/

- GitHub Actions:
- Doesn't offer a UI interface, you write custom build workflows in yaml format, and you can use pre-built actions that are freely avaliable in the GitHub marketplace
- Documentation for the Flutter action: https://github.com/marketplace/actions/flutter-action
- Detailed introduction to GitHub Actions: https://docs.github.com/en/actions/get-started/understand-github-actions
- Video Tutorial: https://www.youtube.com/watch?v=rpQKpXjH5vs
- Actions are powerful but they have a steeper learning curve
- If you make a typo or mistake in workflow file, you can only find out what went wrong by inspectin the build log once the build has completed

- Fastlane:
- Open sourced tool that makeit easy to automate beta deployments and releases for apps
- Particularly useful for managing and updating the code signing certificates and signing release apps
- Many people use Fastlane in their Flutter build workflows, either with GitHub Actions or Codemagic
- Official Flutter documentation offers a good overview of Continious delivery with fastlane: https://docs.flutter.dev/deployment/cd
- Guide for setting up Flutter & Fastlane: https://rodydavis.com/posts/flutter-one-click-release 
- Can take a bit of time to set up Fastlane the first time, but once it's up and running, can save a lot of time in the future

- Releasing to the App Stores:
- Official documentation has important steps that you need to follow in preparation for this:
- Android: https://docs.flutter.dev/deployment/android
- iOS: https://docs.flutter.dev/deployment/ios 
- Firebase launch checklist: https://firebase.google.com/support/guides/launch-checklist

Additional Content:
- Flutter Article from Code with Andre: https://codewithandrea.com/articles/
- Flutter Example Apps on GitHub: https://github.com/bizz84/flutter_example_apps

Questions:
- How do you design software hierarchies - e.g. particular software
- What state management systems do you use?
- What navigation / routing package do you use?
- What testing package do you use?
- What CI / CD systems do you use?